"""
Builds the final GenerationContext object for an 'order' type module.
"""

import pprint
import yaml
from typing import Dict, List, Any

# Import standard OpenAPI to Ansible type mapping and auth options
from ansible_waldur_generator.helpers import (
    AUTH_OPTIONS,
    OPENAPI_TO_ANSIBLE_TYPE_MAP,
    to_python_code_string,
)
from ansible_waldur_generator.models import (
    AnsibleModuleParams,
    BaseGenerationContext,
)
from ansible_waldur_generator.interfaces.builder import BaseContextBuilder
from ansible_waldur_generator.plugins.order.config import OrderModuleConfig

# Import built-in SDK functions and models that this plugin assumes are standard
# for any marketplace order workflow. This is a core part of the plugin's "intelligence".
from waldur_api_client.api.marketplace_orders import (
    marketplace_orders_create,
    marketplace_orders_retrieve,
)
from waldur_api_client.api.marketplace_resources import marketplace_resources_terminate
from waldur_api_client.models import OrderCreateRequest, ResourceTerminateRequest


# Base Ansible 'argument_spec' for all modules generated by this plugin.
# It includes authentication, state management, and async handling parameters,
# ensuring consistency across all generated 'order' modules.
BASE_SPEC = {
    **AUTH_OPTIONS,
    "state": {
        "description": "Should the resource be present or absent.",
        "choices": ["present", "absent"],
        "default": "present",
        "type": "str",
    },
    "wait": {
        "description": "A boolean value that defines whether to wait for the order to complete.",
        "default": True,
        "type": "bool",
    },
    "timeout": {
        "description": "The maximum number of seconds to wait for the order to complete.",
        "default": 600,
        "type": "int",
    },
    "interval": {
        "description": "The interval in seconds for polling the order status.",
        "default": 20,
        "type": "int",
    },
}


class OrderContextBuilder(BaseContextBuilder):
    """Builds the GenerationContext for a marketplace 'order' module."""

    # Explicitly type the module_config for better static analysis and autocompletion.
    module_config: OrderModuleConfig

    def build(self) -> BaseGenerationContext:
        """
        Main entry point to build the full, flattened context for a single module.
        It orchestrates the creation of all necessary data for the template.
        """
        module_name = f"waldur_{self.module_config.module_key}"

        # 1. Build the dictionary of all Ansible parameters for the module.
        parameters = self._build_parameters()

        # 2. Collect all unique SDK imports needed for the module's logic.
        sdk_imports = self._collect_imports()

        # 3. Build the data structures for documentation and examples.
        doc_data = self._build_documentation_data(module_name, parameters)
        examples_data = self._build_examples_data(module_name, parameters)

        # 4. Construct the context dictionary for the runtime runner.
        runner_context_data = self._build_runner_context_data()
        runner_context_string = to_python_code_string(
            runner_context_data, indent_level=4
        )

        # 5. Build the argument_spec dictionary and format it as a Python string.
        argument_spec_data = self._build_argument_spec_data(parameters)
        argument_spec_string = pprint.pformat(
            argument_spec_data, indent=4, width=120, sort_dicts=False
        )

        # 6. Convert documentation and examples data into formatted YAML strings.
        doc_yaml = yaml.dump(
            doc_data, default_flow_style=False, sort_keys=False, indent=2, width=1000
        )
        examples_yaml = yaml.dump(
            examples_data,
            default_flow_style=False,
            sort_keys=False,
            indent=2,
            width=1000,
        )

        # 7. Return the final context object, ready for rendering in Jinja2.
        return BaseGenerationContext(
            module_name=module_name,
            description=self.module_config.description,
            parameters=parameters,
            sdk_imports=sdk_imports,
            documentation_yaml=doc_yaml,
            examples_yaml=examples_yaml,
            runner_class_name="OrderRunner",
            runner_import_path="ansible_waldur_generator.plugins.order.runner",
            runner_context_string=runner_context_string,
            argument_spec_string=argument_spec_string,
        )

    def _build_parameters(self) -> AnsibleModuleParams:
        """
        Creates the complete dictionary of Ansible module parameters by combining
        standard, built-in, and user-configured parameters.
        """
        params: AnsibleModuleParams = {}

        # Add standard parameters (name, project, offering) that are always present.
        params["name"] = {
            "type": "str",
            "required": True,
            "description": f"The name of the {self.module_config.resource_type}.",
        }
        params["project"] = {
            "type": "str",
            "required": True,
            "description": "The name or UUID of the project.",
        }
        params["offering"] = {
            "type": "str",
            "required": True,
            "description": "The name or UUID of the marketplace offering.",
        }
        # A description parameter is almost always useful for updates.
        params["description"] = {
            "type": "str",
            "required": False,
            "description": f"A description for the {self.module_config.resource_type}.",
        }

        # Add parameters defined in the 'attribute_params' section of the config.
        for p_conf in self.module_config.attribute_params:
            param_name = p_conf["name"]
            # Map OpenAPI type to Ansible type, defaulting to 'str'.
            param_type = OPENAPI_TO_ANSIBLE_TYPE_MAP.get(
                p_conf.get("type", "string"), "str"
            )
            # If the parameter is resolved, its description should reflect that.
            description = p_conf.get("description", "")
            if p_conf.get("is_resolved"):
                description = f"The name or UUID of the {param_name}. {description}"

            params[param_name] = {
                "type": param_type,
                "required": p_conf.get("required", False),
                "description": description.strip(),
            }
            if "choices" in p_conf:
                params[param_name]["choices"] = p_conf["choices"]

        return params

    def _collect_imports(self) -> List[Dict[str, str]]:
        """Collects all unique SDK module/function/class pairs needed for the module."""
        imports = set()
        conf = self.module_config

        # 1. Add imports for configured operations (existence check, update).
        operations = [conf.existence_check_op, conf.update_op]
        for op in operations:
            if op:
                imports.add((op.sdk_op.sdk_module_name, op.sdk_op.sdk_function_name))
                if op.sdk_op.model_class:
                    imports.add(
                        (op.sdk_op.model_module_name, op.sdk_op.model_class_name)
                    )

        # 2. Add imports for all configured resolvers.
        for resolver in conf.resolvers.values():
            imports.add(
                (resolver.list_op.sdk_module_name, resolver.list_op.sdk_function_name)
            )
            imports.add(
                (
                    resolver.retrieve_op.sdk_module_name,
                    resolver.retrieve_op.sdk_function_name,
                )
            )

        # 3. Add imports for the built-in, hardcoded functions and models.
        imports.add(
            ("waldur_api_client.api.marketplace_orders", "marketplace_orders_create")
        )
        imports.add(
            ("waldur_api_client.api.marketplace_orders", "marketplace_orders_retrieve")
        )
        imports.add(
            (
                "waldur_api_client.api.marketplace_resources",
                "marketplace_resources_terminate",
            )
        )
        imports.add(("waldur_api_client.models", "OrderCreateRequest"))
        imports.add(("waldur_api_client.models", "ResourceTerminateRequest"))

        # Convert the set of tuples to a sorted list of dictionaries for the template.
        return [
            {"module": mod, "function": func} for mod, func in sorted(list(imports))
        ]

    def _build_runner_context_data(self) -> Dict[str, Any]:
        """
        Builds the context dictionary needed by the OrderRunner at runtime.
        This is a critical step that passes Python functions and configuration
        from the generator to the generated module's logic.
        """
        conf = self.module_config

        # Build a simple dictionary of resolvers for the runner.
        resolvers_data = {}
        for name, resolver in conf.resolvers.items():
            resolvers_data[name] = {
                "list_func": resolver.list_op.sdk_function,
                "retrieve_func": resolver.retrieve_op.sdk_function,
                "error_message": resolver.error_message,
            }

        # Collect the names of parameters that go into the 'attributes' dict.
        attribute_param_names = [p["name"] for p in conf.attribute_params]
        attribute_param_names.append("description")

        # Construct the final context dictionary.
        return {
            "resource_type": conf.resource_type,
            # Configured operations:
            "existence_check_func": conf.existence_check_op.sdk_op.sdk_function,
            "existence_check_filter_keys": {"project": "project_uuid"},
            "update_func": conf.update_op.sdk_op.sdk_function
            if conf.update_op
            else None,
            "update_model_class": conf.update_op.sdk_op.model_class
            if conf.update_op
            else None,
            "update_check_fields": conf.update_check_fields,
            # Built-in (hardcoded) operations and models:
            "order_create_func": marketplace_orders_create,
            "order_poll_func": marketplace_orders_retrieve,
            "terminate_func": marketplace_resources_terminate,
            "order_model_class": OrderCreateRequest,
            "terminate_model_class": ResourceTerminateRequest,
            # Parameter and resolver information for the runner:
            "attribute_param_names": list(
                set(attribute_param_names)
            ),  # Ensure uniqueness
            "resolvers": resolvers_data,
        }

    def _build_argument_spec_data(
        self, parameters: AnsibleModuleParams
    ) -> Dict[str, Any]:
        """Constructs the full 'argument_spec' dictionary for AnsibleModule."""
        spec = {**BASE_SPEC}
        for name, opts in parameters.items():
            param_spec = {"type": opts["type"], "required": opts.get("required", False)}
            if "choices" in opts:
                param_spec["choices"] = opts["choices"]
            spec[name] = param_spec
        return spec

    def _build_documentation_data(
        self, module_name: str, parameters: AnsibleModuleParams
    ) -> Dict[str, Any]:
        """Builds the DOCUMENTATION block as a Python dictionary."""
        doc = {
            "module": module_name,
            "short_description": self.module_config.description,
            "version_added": "0.1.0",
            "description": [self.module_config.description],
            "requirements": ["python >= 3.8", "waldur-api-client"],
            "options": {},
        }
        # Add base spec options (auth, state, etc.)
        doc["options"].update(BASE_SPEC)
        # Add module-specific parameters
        for name, opts in parameters.items():
            doc_data = {
                k: v
                for k, v in opts.items()
                if k in ["description", "required", "type", "choices"] and v is not None
            }
            if "required" not in doc_data:
                doc_data["required"] = False  # Ensure 'required' is always present
            doc["options"][name] = doc_data
        return doc

    def _build_examples_data(
        self, module_name: str, parameters: AnsibleModuleParams
    ) -> List[Dict[str, Any]]:
        """Builds the EXAMPLES block as a list of Python dictionaries."""

        def get_example_params(param_names, extra_params=None):
            """Helper to build the parameter dictionary for a task example."""
            params = {
                "access_token": "b83557fd8e2066e98f27dee8f3b3433cdc4183ce",
                "api_url": "https://waldur.example.com/api",
            }
            if extra_params:
                params.update(extra_params)

            for p_name in param_names:
                info = parameters.get(p_name, {})
                if "project" in p_name:
                    value = "Cloud Project"
                elif "offering" in p_name:
                    value = "Standard Volume Offering"
                elif "name" in p_name:
                    value = f"My-Awesome-{self.module_config.resource_type.replace(' ', '-')}"
                elif "size" in p_name:
                    value = 10
                elif info.get("choices"):
                    value = info["choices"][0]
                else:
                    value = "some_value"
                params[p_name] = value
            return params

        # Get names of required parameters for the 'present' state
        create_param_names = [
            name for name, opts in parameters.items() if opts.get("required")
        ]

        # Prepare parameters for the update example.
        # It needs identifying parameters (name, project) and the field to update.
        update_example_params = {
            "name": f"My-Awesome-{self.module_config.resource_type.replace(' ', '-')}",
            "project": "Cloud Project",
            "state": "present",  # State is 'present' for updates
            "description": "A new updated description for the resource.",
            # Auth params are still needed
            "access_token": "b83557fd8e2066e98f27dee8f3b3433cdc4183ce",
            "api_url": "https://waldur.example.com/api",
        }

        examples = [
            {
                "name": f"Create a new {self.module_config.resource_type}",
                "hosts": "localhost",
                "tasks": [
                    {
                        "name": f"Add {self.module_config.resource_type}",
                        module_name: get_example_params(
                            create_param_names, {"state": "present"}
                        ),
                    }
                ],
            },
            {
                "name": f"Update an existing {self.module_config.resource_type}",
                "hosts": "localhost",
                "tasks": [
                    {
                        "name": f"Update the description of a {self.module_config.resource_type}",
                        module_name: update_example_params,
                    }
                ],
            },
            {
                "name": f"Remove an existing {self.module_config.resource_type}",
                "hosts": "localhost",
                "tasks": [
                    {
                        "name": f"Remove {self.module_config.resource_type}",
                        module_name: {
                            # Only name and project are typically needed for deletion
                            "name": f"My-Awesome-{self.module_config.resource_type.replace(' ', '-')}",
                            "project": "Cloud Project",
                            "state": "absent",
                            # Auth params are still needed
                            "access_token": "b83557fd8e2066e98f27dee8f3b3433cdc4183ce",
                            "api_url": "https://waldur.example.com/api",
                        },
                    }
                ],
            },
        ]

        # Only include the update example if the module actually supports updates.
        if not self.module_config.update_op:
            examples.pop(1)  # Remove the update example at index 1

        return examples

#!/usr/bin/python
#
# THIS FILE IS AUTOGENERATED BY THE ANSIBLE MODULE GENERATOR - DO NOT EDIT
#
{% if resolvers %}
import uuid
{% endif %}
from ansible.module_utils.basic import AnsibleModule
from waldur_api_client.client import AuthenticatedClient
{% for imp in sdk_imports %}
from {{ imp.module }} import {{ imp.function }}
{% endfor %}

ANSIBLE_METADATA = {
    "metadata_version": "1.1",
    "status": ["preview"],
    "supported_by": "OpenNode",
}

DOCUMENTATION = """
---
{{ documentation_yaml | trim | indent(0) }}
"""

EXAMPLES = """
{{ examples_yaml | trim | indent(0) }}
"""

{% if resolvers %}
def _is_uuid(val):
    """Checks if a value is a valid UUID."""
    try:
        uuid.UUID(str(val))
        return True
    except (ValueError, TypeError, AttributeError):
        return False

def _resolve_to_url(module, client, list_func, retrieve_func, value, error_message):
    """
    Resolves a resource name or UUID to its API URL.
    Uses the more efficient 'retrieve' function for UUIDs and 'list' for names.
    """
    if not value:
        return None

    # If the value already looks like a URL, return it directly.
    if str(value).startswith(('http://', 'https://')):
        return value

    try:
        if _is_uuid(value):
            # Use the 'retrieve' function for UUID lookups.
            resource = retrieve_func.sync(client=client, uuid=value)
            resources = [resource] if resource else []
        else:
            # Use the 'list' function for name-based lookups.
            resources = list_func.sync(client=client, name_exact=value)

        if not resources:
            module.fail_json(msg=error_message.format(value=value))
        if len(resources) > 1:
            module.fail_json(msg=f"Multiple resources found for '{value}'. Please use UUID for uniqueness.")

        return resources[0].url
    except Exception as e:
        module.fail_json(msg=f"Failed to resolve '{value}': {str(e)}")
{% endif %}

def main():
    """Main function for the Ansible module."""
    argument_spec = dict(
        access_token=dict(type='str', required=True, no_log=True),
        api_url=dict(type='str', required=True),
        state=dict(type='str', default='present', choices=['present', 'absent']),
    {% for name, opts in parameters.items() %}
        {{ name }}=dict(
            type='{{ opts.type }}',
            required={{ opts.get('required', False) }}
            {% if opts.choices -%}
            , choices={{ opts.choices }}
            {%- endif %}
        ),
    {% endfor %}
    )

    module = AnsibleModule(
        argument_spec=argument_spec,
        supports_check_mode=True,
    )

    client = AuthenticatedClient(base_url=module.params['api_url'], token=module.params['access_token'])
    has_changed = False
    resource = None

    # 1. Check for resource existence using the specified lookup parameter.
    try:
        # Note: The convention is that the existence check uses the 'name' parameter.
        # A more advanced generator could make this configurable.
        existing_resources = {{ existence_check_func }}.sync(client=client, name_exact=module.params['name'])
        resource = existing_resources[0] if existing_resources else None
    except Exception as e:
        module.fail_json(msg=f"Failed to check for {{ resource_type }} existence: {str(e)}")

    # 2. Handle check_mode: predict changes without making them.
    if module.check_mode:
        if module.params['state'] == 'present' and not resource:
            has_changed = True
        elif module.params['state'] == 'absent' and resource:
            has_changed = True
        module.exit_json(changed=has_changed)

    # 3. Apply the desired state.
    if resource:
        # Resource already exists.
        if module.params['state'] == 'absent':
            try:
                {{ absent_destroy_func }}.sync_detailed(client=client, uuid=getattr(resource, '{{ absent_destroy_path_param }}'))
                has_changed = True
                resource = None # The resource is now gone.
            except Exception as e:
                module.fail_json(msg=f"Failed to delete {{ resource_type }} {getattr(resource, 'uuid', '')}: {str(e)}")
    else:
        # Resource does not exist.
        if module.params['state'] == 'present':
            try:
                # 3a. Build the arguments for the SDK model class using a dict comprehension.
                # This collects all parameters from the user that are part of the model's schema
                # and are not handled by resolvers.
                model_param_names = {
                    {% for param_name, prop_opts in present_create_model_schema.properties.items() if not prop_opts.is_resolved %}
                    '{{ param_name }}',
                    {% endfor %}
                }
                model_args = {
                    key: module.params[key]
                    for key in model_param_names
                    if key in module.params and module.params[key] is not None
                }

                # 3b. Resolve any parameters that require name/UUID to URL conversion.
                # This will overwrite the user-provided name with the resolved URL in model_args.
                {% if resolvers %}
                {% for param_name, resolver in resolvers.items() %}
                if module.params.get('{{ param_name }}'):
                    model_args['{{ param_name }}'] = _resolve_to_url(
                        module=module, client=client,
                        list_func={{ resolver.list_func }},
                        retrieve_func={{ resolver.retrieve_func }},
                        value=module.params['{{ param_name }}'],
                        error_message="{{ resolver.error_message }}",
                    )
                {% endfor %}
                {% endif %}

                # 3c. Instantiate the request model and call the SDK create function.
                request_body = {{ present_create_model_class }}(**model_args)
                resource = {{ present_create_func }}.sync(client=client, body=request_body)
                has_changed = True
            except Exception as e:
                module.fail_json(msg=f"Failed to create {{ resource_type }}: {str(e)}")

    # 4. Return the final state of the resource.
    resource_dict = resource.to_dict() if resource and hasattr(resource, 'to_dict') else None
    module.exit_json(changed=has_changed, resource=resource_dict)


if __name__ == '__main__':
    main()
